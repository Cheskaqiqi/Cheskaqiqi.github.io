<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GSoC week3-4</title>
      <link href="/2023/06/19/Week3-4/"/>
      <url>/2023/06/19/Week3-4/</url>
      
        <content type="html"><![CDATA[<h1 id="week3-4"><a href="#week3-4" class="headerlink" title="week3-4"></a>week3-4</h1><p>When I started studying git worktree, I went through a period of mental confusion. At first, I started studying the documentation to get familiar with the command, which differs significantly from other commands: it manages multiple working trees attached to the same repository. I spent a lot of time understanding this concept, and it was only after trying to use the command that I understood how it should be used. However, I was still puzzled by this concept. I wondered how it was related to the index, since it creates a new working tree each time. When I was confused, I thought I should seriously study the source code and look for places where it interacts with the index.</p><p>I eventually found two places related to the index:</p><ol><li><p>The ‘validate_no_submodules’ function, which checks if there are any submodules present in the worktree.</p></li><li><p>The ‘check_clean_worktree’ function, which verifies if a worktree is ‘clean’, i.e., there are no untracked or modified but uncommitted files. This is done by running the ‘git status’ command, and an error message is thrown if the worktree is not clean. Given that ‘git status’ is already sparse-aware, the function is also sparse-aware.</p></li></ol><p>So the next steps were quite similar to those with diff-tree, as we had evidence to show that we didn’t need to do any extra handling of the index. Finally, we didn’t see a significant improvement in performance testing, mainly because the time taken to read the index is minuscule compared to filesystem operations.</p>]]></content>
      
      
      <categories>
          
          <category> GSoC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GSoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GSoC week1-2</title>
      <link href="/2023/06/19/Week1-2/"/>
      <url>/2023/06/19/Week1-2/</url>
      
        <content type="html"><![CDATA[<h1 id="week1-2"><a href="#week1-2" class="headerlink" title="week1-2"></a>week1-2</h1><p>During the first week, I mainly dove into the documentation of git diff-tree, and also skimmed through the source code to help me write better tests. Diff-tree primarily has two commands related to the index: one is “Compares the content and mode of the blobs found via two tree objects”, and the other one compares commit objects. Therefore, I wrote tests around these two aspects. Super luckily, when I set the “requires-full-index” to false for “diff-tree”, all the tests passed. This indirectly proves that “diff-tree” might have successfully implemented sparse indexing. </p><p>But that’s not enough. We need to be certain that this sparse index integration is correct. We should verify that the intended usage associated with those two reads will still work with a sparse index.</p><p>So, I started digging into the source code, trying to find proof of lower-level functions already being sparse-aware, but I couldn’t find any. Thanks to the help of my mentor, who clarified a lot of concepts for me after I posted my first RFC patch, I came to understand the reasons for the successful integration:</p><ol><li><p>The first index read was added in fd66bcc31ff (diff-tree: read the index so attribute checks work in bare repositories, 2017-12-06) to deal with reading ‘.gitattributes’ content. 77efbb366ab (attr: be careful about sparse directories, 2021-09-08) established that, in a sparse index, we do <em>not</em> try to load a ‘.gitattributes’ file from within a sparse directory. </p></li><li><p>The second index access point is involved in rename detection, specifically when reading from stdin. This was initially added in f0c6b2a2fd9 ([PATCH] Optimize diff-tree -[CM]–stdin, 2005-05-27), where ‘setup’ was set to ‘DIFF_SETUP_USE_SIZE_CACHE |DIFF_SETUP_USE_CACHE’. That assignment was later modified to drop the ‘DIFF_SETUP_USE_CACHE’ in ff7fe37b053 (diff.c: move read_index() code back to the caller, 2018-08-13). However, ‘DIFF_SETUP_USE_SIZE_CACHE’ seems to be unused as of 6e0b8ed6d35 (diff.c: do not use a separate “size cache”., 2007-05-07) and nothing about ‘detect_rename’ otherwise indicates index usage.</p></li></ol><p>Therefore, we ensured that the integration is comprehensive and correct. Finally, in performance tests, everything was as expected, achieving a ~98% reduction in execution time.</p>]]></content>
      
      
      <categories>
          
          <category> GSoC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GSoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATHEMATICAL INDUCTION</title>
      <link href="/2022/09/17/New%20Document/"/>
      <url>/2022/09/17/New%20Document/</url>
      
        <content type="html"><![CDATA[<p>#How Does Induction Work</p><p>T is a theorem with a parameter n ≥ 1.</p><p>• If we show that:</p><ol><li>T holds for n = 1 (or a small number d, if n ≥ d)</li><li>For every n ≥ 1</li></ol><p>If T holds for n<br>then T holds for n + 1</p><p>• Then theorem T holds for all n ≥ 1. The assumption that T holds for n is called induction hypothesis</p><p>#Strong Induction</p><p>A statement T with a parameter n is true for n = 1 and<br>if, for every n ≥ 1 the following holds:</p><p>T being true for every natural number m ≤ n implies that T is true for n + 1, then T is true for all natural numbers</p><p>Also, power(2) induction: induction on natural numbers that are integer powers of 2 Multiple induction: base case for one parameter required another induction on another parameter.</p>]]></content>
      
      
      <categories>
          
          <category> ANALYSIS OF ALGORITHMS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BINARY SEARCH AND VARIATIONS</title>
      <link href="/2022/02/11/red-black-tree/"/>
      <url>/2022/02/11/red-black-tree/</url>
      
        <content type="html"><![CDATA[<p>#Binary Search and Variations</p><ul><li>Idea: cut search space in half (about half) by asking only one question.</li><li>Also work when, with constant time, cut search space from n to n<br>a, where a &gt; 1.</li><li>Used often in computer science.</li><li>Pure binary search</li></ul><p>x1, x2, . . . , xn is a sequence of real numbers such that<br>x1 ≤ x2 ≤ · · · ≤ xn<br>Problem: Given a real number z, we want to find whether z appears in the sequence, and<br>if it does, to find an index i such that xi = z.<br>Solution: binary search!</p><p>Binary search:<br>Question: “Is xn/2 &lt; z?”<br>Yes: binary search range becomes xn/2+1, . . . xn<br>No: binary search range becomes x1, . . . , xn/2<br>Complexity: O(log2 n).</p><p>#A More General Version<br>Input: a sorted sequence, x1 ≤ x2 ≤ . . . ≤ xn, and a target value z<br>Output: the largest index i, s.t. xi ≤ z, if there is no such i then return 0;</p><ol><li>If x1 &gt; z, return 0;</li><li>If xn ≤ z, return n;</li><li>l = 1; r = n; (xl ≤ z &lt; xr)</li><li>if l = r − 1 return l;</li><li>Set m to b<br>l+r/2，the greatest integer less than or equal to l+r/2<br>which is the middle between l and r</li><li>if xm &gt; z, then r = m; goto step 4;</li><li>if xm ≤ z, then l = m; goto step 4;</li></ol><p>#Binary Search in a Cyclic Sequence<br>Definition. A sequence x1, x2, . . . , xn is said to be cyclically sorted if the smallest<br>number in the sequence is xi<br>for some unknown i, and the sequence<br>xi<br>, xi+1, . . . , xn, x1, x2, . . . , xi−1<br>is sorted.<br>The Problem: Given a cyclically sorted list, find the position of the minimum element in<br>the list (we assume elements are distinct).</p><p>Solution: For any two numbers xk, xm, such that k &lt; m, compare xk with xm.</p><ol><li>If xk &lt; xm then i cannot be in the range k &lt; j ≤ m (k is possible)</li><li>If xk &gt; xm then i must be in the range k &lt; j ≤ m</li></ol><p>Is xn/2 &lt; xn?<br>Yes: search range 1 . . . n/2. No: search range n/2 + 1, . . . n.<br>Find the index of the smallest element in O(logn) time</p>]]></content>
      
      
      <categories>
          
          <category> ANALYSIS OF ALGORITHMS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cs </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
